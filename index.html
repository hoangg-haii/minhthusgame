<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gh√©p 3 - game cho V·ª£</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap');

        body {
            font-family: 'Quicksand', sans-serif;
            background: #fff1f2;
            overflow: hidden;
            touch-action: manipulation;
        }

        .game-container {
            max-width: 500px;
            margin: 0 auto;
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .board-wrapper {
            position: relative;
            flex-grow: 1;
            margin: 10px;
            padding: 10px;
            background: #ffe4e6;
            border: 6px solid #fecdd3;
            border-radius: 24px;
            box-shadow: 0 8px 20px rgba(225, 29, 72, 0.1);
            overflow: hidden;
        }

        #game-board {
            position: relative;
            width: 100%;
            height: 100%;
            background: #fff5f5;
            border-radius: 16px;
            overflow: hidden;
        }

        .item {
            position: absolute;
            width: 54px;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), filter 0.3s;
            user-select: none;
            border: 2px solid #fb7185;
        }

        .item.locked {
            filter: brightness(0.4) grayscale(1);
            cursor: not-allowed;
            opacity: 0.8;
            border-color: #94a3b8;
        }

        /* Thanh ch·ª©a ph√≠a d∆∞·ªõi */
        .dock-container {
            height: 80px;
            background: #fda4af;
            margin: 10px 15px 20px 15px;
            border-radius: 16px;
            border: 4px solid #fb7185;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 0 10px;
            gap: 6px;
            position: relative;
        }

        .dock-slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            transition: all 0.2s ease;
        }

        .progress-bar {
            height: 12px;
            background: #f1f5f9;
            border-radius: 20px;
            border: 2px solid #fda4af;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fb7185, #f43f5e);
            width: 100%;
            transition: width 0.2s ease-out;
        }

        .modal {
            background: rgba(76, 5, 25, 0.5);
            backdrop-filter: blur(10px);
        }

        /* Hi·ªáu ·ª©ng bay */
        .flying-item {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 28px;
            background: white;
            border-radius: 12px;
            border: 2px solid #fb7185;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 15px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>

    <div class="game-container">
        <!-- Header -->
        <div class="p-4 flex justify-between items-center">
            <div>
                <h1 class="text-2xl font-black text-pink-600 uppercase">Cute Match 3</h1>
                <p class="text-[10px] font-bold text-pink-400 uppercase tracking-widest">C·∫•p ƒë·ªô: <span id="current-level" class="text-pink-600">1</span></p>
            </div>
            <div class="text-right">
                <p class="text-2xl font-black text-pink-600" id="score">0</p>
                <p class="text-[10px] font-bold text-gray-400 uppercase">ƒêi·ªÉm</p>
            </div>
        </div>

        <!-- Timer -->
        <div class="px-6 mb-2">
            <div class="progress-bar">
                <div id="timer-fill" class="progress-fill"></div>
            </div>
        </div>

        <!-- Game Board -->
        <div class="board-wrapper">
            <div id="game-board"></div>
        </div>

        <!-- Dock (Thanh ch·ª©a) -->
        <div class="dock-container" id="dock">
            <!-- Slots will be here -->
        </div>

        <!-- Controls -->
        <div class="p-4 flex gap-3">
            <button onclick="useHint()" class="flex-1 bg-amber-400 hover:bg-amber-500 text-white py-3 rounded-xl font-black shadow-[0_4px_0_#d97706] active:translate-y-1 active:shadow-none transition-all text-sm">
                G·ª¢I √ù
            </button>
            <button onclick="shuffleBoard()" class="flex-1 bg-rose-400 hover:bg-rose-500 text-white py-3 rounded-xl font-black shadow-[0_4px_0_#e11d48] active:translate-y-1 active:shadow-none transition-all text-sm">
                X√ÅO B√ÄI
            </button>
        </div>
    </div>

    <!-- Modals -->
    <div id="game-modal" class="modal fixed inset-0 hidden flex items-center justify-center z-[200]">
        <div class="bg-white p-8 rounded-[32px] text-center max-w-xs w-full shadow-2xl border-4 border-pink-100 mx-4">
            <h2 id="modal-title" class="text-2xl font-black text-pink-600 mb-2">Th·∫Øng r·ªìi!</h2>
            <p id="modal-desc" class="text-gray-500 font-medium mb-6">B·∫°n th·∫≠t xu·∫•t s·∫Øc.</p>
            <button id="modal-btn" class="bg-pink-500 hover:bg-pink-600 text-white w-full py-4 rounded-xl font-black text-lg shadow-lg active:scale-95 transition-transform">TI·∫æP T·ª§C</button>
        </div>
    </div>

    <script>
        const emojis = ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'üê§', 'ü¶Ü'];
        const board = document.getElementById('game-board');
        const dockEl = document.getElementById('dock');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('current-level');
        const timerFill = document.getElementById('timer-fill');
        
        const DOCK_SIZE = 7;
        
        let state = {
            score: 0,
            level: 1,
            timeLeft: 60,
            maxTime: 60,
            items: [],
            dock: [],
            timer: null,
            isGameOver: false,
            isProcessing: false
        };

        const playSound = (type) => {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                if (type === 'match') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1);
                } else if (type === 'click') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, ctx.currentTime);
                } else if (type === 'error') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, ctx.currentTime);
                }
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                osc.start();
                osc.stop(ctx.currentTime + 0.2);
            } catch(e) {}
        };

        function initLevel() {
            state.isGameOver = false;
            state.isProcessing = false;
            state.items = [];
            state.dock = [];
            state.timeLeft = Math.max(45, 100 - (state.level * 5));
            state.maxTime = state.timeLeft;
            board.innerHTML = '';
            levelEl.innerText = state.level;
            renderDock();
            
            const totalTriples = 4 + (state.level * 2);
            const layersCount = Math.min(6, 2 + Math.floor(state.level / 2));
            
            const padding = 10;
            const itemSize = 54;
            const maxW = board.clientWidth - itemSize - padding;
            const maxH = board.clientHeight - itemSize - padding;

            // T·∫°o to√†n b·ªô danh s√°ch emoji (lu√¥n ƒë·ªß b·ªô 3)
            let emojiPool = [];
            for (let t = 0; t < totalTriples; t++) {
                const emoji = emojis[Math.floor(Math.random() * emojis.length)];
                emojiPool.push(emoji, emoji, emoji);
            }
            // X√°o tr·ªôn pool
            emojiPool.sort(() => Math.random() - 0.5);

            // Ph√¢n b·ªï ng·∫´u nhi√™n v√†o c√°c l·ªõp (kh√¥ng c·∫ßn ch·∫µn l·∫ª trong 1 l·ªõp)
            let currentPoolIdx = 0;
            for(let l = 0; l < layersCount; l++) {
                // L·ªõp c√†ng tr√™n (l nh·ªè) c√†ng c√≥ nhi·ªÅu icon h∆°n ho·∫∑c ph√¢n b·ªï ƒë·ªÅu
                let countInLayer;
                if (l === layersCount - 1) {
                    countInLayer = emojiPool.length - currentPoolIdx;
                } else {
                    // Ph√¢n b·ªï ng·∫´u nhi√™n nh∆∞ng ƒë·∫£m b·∫£o kh√¥ng h·∫øt pool qu√° s·ªõm
                    const remaining = emojiPool.length - currentPoolIdx;
                    countInLayer = Math.floor(Math.random() * (remaining / (layersCount - l))) + 3;
                }

                for (let i = 0; i < countInLayer && currentPoolIdx < emojiPool.length; i++) {
                    state.items.push({
                        id: Math.random().toString(36).substr(2, 9),
                        emoji: emojiPool[currentPoolIdx++],
                        layer: l,
                        x: padding + Math.random() * maxW,
                        y: padding + Math.random() * maxH,
                        removed: false
                    });
                }
            }

            renderBoard();
            startTimer();
        }

        function renderDock() {
            dockEl.innerHTML = '';
            for (let i = 0; i < DOCK_SIZE; i++) {
                const slot = document.createElement('div');
                slot.className = 'dock-slot';
                if (state.dock[i]) {
                    slot.innerText = state.dock[i];
                    slot.style.background = "white";
                    slot.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
                    slot.style.border = "2px solid #fb7185";
                }
                dockEl.appendChild(slot);
            }
        }

        function renderBoard() {
            const activeLayer = getActiveLayer();
            const currentItems = state.items.filter(i => !i.removed);

            // X·ª≠ l√Ω DOM
            const existingEls = board.querySelectorAll('.item');
            const existingIds = Array.from(existingEls).map(el => el.dataset.id);
            
            // X√≥a ph·∫ßn t·ª≠ c≈©
            existingIds.forEach(id => {
                if (!currentItems.find(i => i.id === id)) {
                    board.querySelector(`[data-id="${id}"]`)?.remove();
                }
            });

            // V·∫Ω / C·∫≠p nh·∫≠t ph·∫ßn t·ª≠
            currentItems.sort((a,b) => b.layer - a.layer).forEach(item => {
                let el = board.querySelector(`[data-id="${item.id}"]`);
                if (!el) {
                    el = document.createElement('div');
                    el.className = 'item';
                    el.dataset.id = item.id;
                    el.innerText = item.emoji;
                    board.appendChild(el);
                }
                
                el.style.left = item.x + 'px';
                el.style.top = item.y + 'px';
                el.style.zIndex = 100 - item.layer;
                
                if(item.layer !== activeLayer) {
                    el.classList.add('locked');
                } else {
                    el.classList.remove('locked');
                }

                el.onclick = () => handleItemClick(item, activeLayer, el);
            });

            if(state.items.every(i => i.removed) && state.dock.length === 0) winGame();
        }

        function getActiveLayer() {
            const remaining = state.items.filter(i => !i.removed);
            if(remaining.length === 0) return -1;
            return Math.min(...remaining.map(i => i.layer));
        }

        function handleItemClick(item, activeLayer, originalEl) {
            if(state.isGameOver || state.isProcessing || item.removed || item.layer !== activeLayer) return;
            if(state.dock.length >= DOCK_SIZE) return;

            state.isProcessing = true;
            playSound('click');

            // T√≠nh to√°n v·ªã tr√≠ bay
            const rect = originalEl.getBoundingClientRect();
            
            // T√¨m v·ªã tr√≠ ch√®n trong dock (nh√≥m c√°c h√¨nh gi·ªëng nhau)
            let insertIdx = state.dock.lastIndexOf(item.emoji);
            if (insertIdx === -1) insertIdx = state.dock.length;
            else insertIdx++;

            // T·∫°o element bay ƒë·ªÉ kh√¥ng l√†m gi√°n ƒëo·∫°n render board
            const flyer = document.createElement('div');
            flyer.className = 'flying-item';
            flyer.innerText = item.emoji;
            flyer.style.left = rect.left + 'px';
            flyer.style.top = rect.top + 'px';
            flyer.style.width = rect.width + 'px';
            flyer.style.height = rect.height + 'px';
            document.body.appendChild(flyer);

            // ƒê√°nh d·∫•u ƒë√£ x√≥a ngay l·∫≠p t·ª©c
            item.removed = true;
            originalEl.style.visibility = 'hidden';

            // C·∫≠p nh·∫≠t m·∫£ng dock ngay ƒë·ªÉ t√≠nh to√°n slot
            state.dock.splice(insertIdx, 0, item.emoji);
            renderDock(); // Render c√°c √¥ tr·ªëng tr∆∞·ªõc

            // L·∫•y t·ªça ƒë·ªô ƒë√≠ch (√¥ trong dock)
            const targetSlot = dockEl.children[insertIdx];
            const targetRect = targetSlot.getBoundingClientRect();

            // Th·ª±c hi·ªán bay
            requestAnimationFrame(() => {
                flyer.style.left = targetRect.left + 'px';
                flyer.style.top = targetRect.top + 'px';
                flyer.style.width = targetRect.width + 'px';
                flyer.style.height = targetRect.height + 'px';
                flyer.style.transform = 'scale(1)';
            });

            setTimeout(() => {
                flyer.remove();
                checkMatch3();
                renderBoard();
                renderDock();
                state.isProcessing = false;
                
                if (state.dock.length >= DOCK_SIZE) {
                    setTimeout(() => {
                        if (state.isGameOver) return;
                        gameOver("Thanh ch·ª©a ƒë√£ ƒë·∫ßy!");
                    }, 100);
                }
            }, 500);
        }

        function checkMatch3() {
            const counts = {};
            state.dock.forEach(emoji => counts[emoji] = (counts[emoji] || 0) + 1);
            
            for (let emoji in counts) {
                if (counts[emoji] >= 3) {
                    playSound('match');
                    state.score += 30;
                    scoreEl.innerText = state.score;
                    
                    let removedCount = 0;
                    state.dock = state.dock.filter(e => {
                        if (e === emoji && removedCount < 3) {
                            removedCount++;
                            return false;
                        }
                        return true;
                    });
                }
            }
        }

        function startTimer() {
            clearInterval(state.timer);
            state.timer = setInterval(() => {
                if(state.isGameOver) return;
                state.timeLeft -= 0.1;
                const percent = (state.timeLeft / state.maxTime) * 100;
                timerFill.style.width = percent + '%';
                if(state.timeLeft <= 0) gameOver("H·∫øt th·ªùi gian!");
            }, 100);
        }

        function useHint() {
            const activeLayer = getActiveLayer();
            const activeItems = state.items.filter(i => !i.removed && i.layer === activeLayer);
            if(activeItems.length > 0) {
                const randomItem = activeItems[Math.floor(Math.random() * activeItems.length)];
                const els = document.querySelectorAll('.item:not(.locked)');
                els.forEach(el => {
                    if(el.innerText === randomItem.emoji) {
                        el.style.boxShadow = "0 0 20px #fbbf24";
                        el.style.borderColor = "#fbbf24";
                        setTimeout(() => {
                            el.style.boxShadow = "";
                            el.style.borderColor = "";
                        }, 1000);
                    }
                });
            }
        }

        function shuffleBoard() {
            const activeLayer = getActiveLayer();
            const remainingInLayer = state.items.filter(i => !i.removed && i.layer === activeLayer);
            const emojisRem = remainingInLayer.map(i => i.emoji).sort(() => Math.random() - 0.5);
            let idx = 0;
            state.items.forEach(i => {
                if(!i.removed && i.layer === activeLayer) i.emoji = emojisRem[idx++];
            });
            renderBoard();
        }

        function winGame() {
            clearInterval(state.timer);
            state.isGameOver = true;
            showModal("Ho√†n th√†nh!", `V∆∞·ª£t qua C·∫•p ƒë·ªô ${state.level}!`, () => {
                state.level++;
                initLevel();
                hideModal();
            });
        }

        function gameOver(reason) {
            if (state.isGameOver) return;
            clearInterval(state.timer);
            state.isGameOver = true;
            playSound('error');
            showModal("K·∫øt th√∫c!", reason, () => {
                state.score = 0;
                scoreEl.innerText = "0";
                state.level = 1;
                initLevel();
                hideModal();
            });
        }

        function showModal(title, desc, btnAction) {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-desc').innerText = desc;
            const btn = document.getElementById('modal-btn');
            btn.onclick = btnAction;
            document.getElementById('game-modal').classList.remove('hidden');
        }

        function hideModal() {
            document.getElementById('game-modal').classList.add('hidden');
        }

        window.onload = initLevel;
    </script>
</body>
</html>
